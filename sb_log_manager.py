"""Collects log files generated by other SB apps for import into Django

"""
import configparser
from datetime import datetime, timedelta, timezone
from django.core.wsgi import get_wsgi_application
from django.utils import timezone
import json
import logging
import logging.config
import os
import re
import sys
from unipath import Path, FILES

def determine_next_date(minute_code, hour_code, day_code, month_code, weekday_code):
    """Determines next update date based on the provided criteria"""
    def convert_month_code(month_code):
        """Converts provided month code to numerical list"""
        # Split comma separated codes into a list
        split_codes = month_code.split(",")

        # Convert any */# codes or ABC codes into specific months
        codes = []

        alpha_months = {
                    "JAN": 1,
                    "FEB": 2,
                    "MAR": 3,
                    "APR": 4,
                    "MAY": 5,
                    "JUN": 6,
                    "JUL": 7,
                    "AUG": 8,
                    "SEP": 9,
                    "OCT": 10,
                    "NOV": 11,
                    "DEC": 12
                }

        for code in split_codes:
            mod_regex = re.match(r"^\*/(\d+)$", code)
            alpha_regex = re.match(r"^[A-Z]+$", code.upper().trim())

            if mod_regex:
                i = 1
                interval = int(mod_regex.group(1))

                while i <= 12:
                    codes.append(i)    
                    i = i + interval

            elif alpha_regex:
                codes.append(alpha_months[code.upper().trim()])
            else:
                codes.append(int(code))

        return codes

    def convert_weekday_code(weekday_code):
        """Converts provided weekday code to numerical list"""
        split_codes = weekday_code.split(",")

        # Converts any alpha codes into numbers
        codes = []

        alpha_weekdays = {
            "SUN": 0,
            "MON": 1,
            "TUE": 2,
            "WED": 3,
            "THU": 4,
            "FRI": 5,
            "SAT": 6
        }

        for code in split_codes:
            # Match for capital letters, removing whitespace
            alpha_regex = re.match(r"^[A-Z]+$", code.upper().trim())

            if alpha_regex:
                codes.append(alpha_weekdays[code.upper().trim()])
            else:
                codes.append(int(code))

    def convert_day_code(day_code):
        """Converts provided day code to numerical list"""
        split_codes = day_code.split(",")

        codes = []

        for code in split_codes:
            mod_regex = re.match(r"^\*/(\d+)$", code)

            if mod_regex:
                i = 1
                interval = int(mod_regex.group(1))

                while i <= 31:
                    codes.append(i)    
                    i = i + interval
            else:
                coes.append(int(code))

        return codes

    def convert_hour_code(hour_code):
        """Converts provide hour code to numerical list"""
        split_codes = hour_code.split(",")

        codes = []

        for code in split_codes:
            mod_regex = re.match(r"^\*/(\d+)$", code)

            if mod_regex:
                i = 0
                interval = int(mod_regex.group(1))

                while i <= 23:
                    codes.append(i)    
                    i = i + interval
            else:
                coes.append(int(code))

        return codes

    def convert_minute_code(minute_code):
        """Converts provided minute code to numerical list"""
        split_codes = day_code.split(",")

        codes = []

        for code in split_codes:
            mod_regex = re.match(r"^\*/(\d+)$", code)

            if mod_regex:
                i = 0
                interval = int(mod_regex.group(1))

                while i <= 59:
                    codes.append(i)    
                    i = i + interval
            else:
                coes.append(int(code))

        return codes
    
        month_codes = convert_month_code(month_code)
        weekday_codes = convert_weekday_code(weekday_code)
        day_codes = convert_day_code(day_code)
        hour_codes = convert_hour_code(hour_code)
        minute_codes = convert_minute_code(minute_code)
    
    # Properly format all the codes
    month_codes = convert_month_code(month_code) if month_code else None
    weekday_codes = convert_weekday_code(weekday_code) if weekday_code else None
    day_codes = convert_day_code(day_code) if day_code else None
    hour_codes = convert_hour_code(hour_code) if hour_code else None
    minute_codes = convert_minute_code(minute_code) if minute_code else None
    
    now = datetime.now()
    
    if month_codes:
        # Check if there is also a day to match or not
        if weekday_code or day_codes:
            # Iterate through days
            next_month
            next_day
        else:
            # Just find matching month
            current_month = now.month()

            for m in range(1,13):
                test_month = current_month + m

                if test_month in month_codes:
                    break
            
            next_month = m
            next_day = 0
    elif weekday_codes or day_codes:
        # No month code to find, just iterate through days
        current_day = now.day()

        # Cycle through the next ~11 years to find a match
        for d in range(0, 4020):
            test_day = current_day + timedelta(day=d)

            weekday_match = False
            day_match = False

            if weekday_codes:
                if test_day.weekday() in weekday_codes:
                    weekday_match = True
            else:
                weekday_match = True
            
            if day_codes:
                # TODO: Add functionality for day in day_codes 
                # exceeding the number of days in the month
                if test_day.day() in day_codes:
                    day_match = True
            else:
                day_match = True

            if weekday_match and day_match:
                break

        next_month = 0
        next_day = d
    else:
        # Any day and month matches
        next_month = 0
        next_day = 0

    if hour_codes:
        current_hour = now.hour()

        for h in range(0,24):
            test_hour = current_hour + h
            
            if test_hour in hour_codes:
                break

        next_hour = h
    else:
        next_hour = 0

    if minute_codes:
        current_minute = now.minute()

        for m in range(0,60):
            test_minute = current_minute + m

            if test_minute in minute_codes:
                break

        next_minute = m
    else:
        next_minute = 1


    next_datetime = now + timedelta()


def process_line(line):
    # Remove the newline characters at the end of the string
    line = line.rstrip("\r\n")

    # Set up regex patterns
    re_section = r"###.*?###"
    re_backslash = r"(?<=[^\\])(\\)(?=[^\\])"

    # Cycle through and find all the sections
    line_sections = []
    last_section_end = 0

    for section in re.finditer(re_section, line):
        # Get the section to workon
        section_start = section.span()[0]
        section_end = section.span()[1]
        section_stub = line[section_start:section_end]

        # Add all preceding text to the new line section array
        line_sections.append(line[last_section_end:section_start])
        last_section_end = section_end

        # Escape any single backslashes
        new_stub = []
        last_match_end = 0

        if re.search(re_backslash, section_stub):
            for match in re.finditer(re_backslash, section_stub):
                match_start = match.span()[0]
                match_end = match.span()[1]
                match_stub = section_stub[match_start:match_end]

                # Add all preceding text to the new stub array
                new_stub.append(section_stub[last_match_end:match_start])
                last_match_end = match_end

                # Escape all single backslashes
                new_stub.append(match_stub.replace("\\", "\\\\"))
            
            # Add the remaining sub to the new_stub
            new_stub.append(section_stub[last_match_end:])
            
            # Reassemble the stub for the next replacement
            section_stub = "".join(new_stub)

        # Remove the section markers
        section_stub = section_stub.replace("###", '"')

        # Add the modified stub to the lines_sections
        line_sections.append(section_stub)

    # Add the remaining section back to the line
    line_sections.append(line[last_section_end:])

    # Assemble the line sections into the final string
    return "".join(line_sections)

# Setup the root path
root = Path(sys.argv[1])

# Setup connection to the config file
config = configparser.ConfigParser()
config.read(Path(root.parent, "config", "sb_log_manager.cfg"))

# Setup logging for this application
logging.config.fileConfig(
    Path(root.parent, "config", "sb_log_manager_logging.cfg")
)
log = logging.getLogger(__name__)

# Setup connection to the Django application
djangoApp = config.get("django", "location")

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "studybuffalo.settings")
sys.path.append(djangoApp)
application = get_wsgi_application()

from log_manager.models import AppData, LogEntry

# Retrieve a list of the applications to monitor
log.info("Retrieving application list with reviews due")
now = timezone.now()
app_list = AppData.objects.filter(next_review__lte=now)

# Retrieve each applicable application log
for app in app_list:
    log.info("Retrieving log data for {}".format(app.name))

    # Set up the directory containing all the logs
    log_directory = Path(app.log_location)

    log.debug("Log Location = {}".format(log_directory))

    # Cycle through all retrieved files looking for files 
    # matching the file name regex
    log.debug("File name regex = {}".format(app.file_name))

    name_regex = r"{}".format(app.file_name)
    app_logs = []

    for file in log_directory.listdir(names_only=True):
        log.debug("File name in log directory = {}".format(file))

        if re.match(name_regex, file):
            log.debug("Regex matches file name")

            app_logs.append(log_directory.child(file))

    # Open the log(s) and form them into a single json file
    log_lines = []

    for app_log in app_logs:
        log.debug("Opening log file: {}".format(app_log))

        with open(app_log, "r") as file:
            for line in file:
                log_lines.append(process_line(line))

    log_text = "[{}]".format(",".join(log_lines))
    
    try:
        unfiltered_log= json.loads(log_text)
    except Exception as e:
        log.warn("Unable to load json log: {}".format(e))

    # Filter the application log based on last screened log datetime
    log.debug("Filtering log entries to only include the most recent")
    log = []
    import pytz

    for entry in unfiltered_log:
        log_date = datetime.strptime(entry["asctime"], "%Y-%m-%d %H:%M:%S.%f")

        if compare_date > app.last_reviewed_log:
            log.append(entry)

    # Check if this app is being monitored for proper stop and starts
    if app.flag_start:
        if any(app.flag_start in entry.message for entry in log):
            log.info("App {} has started properly".format(app.name))
        else:
            log.info("App {} did not start properly".format(app.name))

    if app.flag_end:
        if any(app.flag_end in entry.message for entry in log):
            log.info("App {} completed properly".format(app.name))
        else:
            log.info("App {} did complete properly".format(app.name))

    # Process the JSON log and import into the django database
    for entry in log:
        # Extract all the json values
        asc_time = entry["asctime"] if entry["asctime"] else None
        created = entry["created"] if entry["created"] else None
        exc_info = entry["exc_info"] if entry["exc_info"] else None
        file_name = entry["filename"] if entry["filename"] else None
        func_name = entry["funcName"] if entry["funcName"] else None
        level_name = entry["levelname"] if entry["levelname"] else None
        level_no = entry["levelno"] if entry["levelno"] else None
        line_no = entry["lineno"] if entry["lineno"] else None
        message = entry["message"] if entry["message"] else None
        module = entry["module"] if entry["module"] else None
        msecs = entry["msecs"] if entry["msecs"] else None
        name = entry["name"] if entry["name"] else None
        path_name = entry["pathname"] if entry["pathname"] else None
        process = entry["process"] if entry["process"] else None
        process_name = entry["processName"] if entry["processName"] else None
        relative_created = entry["relativeCreated"] if entry["relativeCreated"] else None
        stack_info = entry["stack_info"] if entry["stack_info"] else None
        thread = entry["thread"] if entry["thread"] else None
        thread_name = entry["threadName"] if entry["threadName"] else None

        # Create a new entry for the LogEntry module
        new_entry = LogEntry(
            app_name=app.id,
            asc_time=asc_time,
            created=created,
            exc_info=exc_info,
            file_name=file_name,
            func_name=func_name,
            level_name=level_name,
            level_no=level_no,
            line_no=line_no,
            message=message,
            module=module,
            msecs=msecs,
            name=name,
            path_name=path_name,
            process=process,
            process_name=process_name,
            relative_created=relative_created,
            stack_info=stack_info,
            thread=thread,
            thread_name=thread_name,
        )
        
        new_entry.save()

    # Update the app last_reviewed_log date and next review date
    app.last_reviewed_log = log[-1]["asc_time"]
    app.next_review_date = determine_next_date(
        app.review_minute,
        app.review_hour,
        app.review_day,
        app.review_month,
        app.review_weekday
    )

    app.update()